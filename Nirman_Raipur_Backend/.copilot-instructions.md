# GitHub Copilot Instructions for Nirman Jashpur Backend

## Project Overview
This is a Node.js/Express.js backend API for managing construction work progress, orders, tenders, and administrative approvals in Jashpur district. The project uses MongoDB with Mongoose for data persistence.

## Architecture & Technology Stack
- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: MongoDB with Mongoose ODM
- **Authentication**: JWT (jsonwebtoken)
- **Validation**: express-validator
- **Security**: helmet, cors, express-rate-limit
- **Testing**: Jest with supertest and mongodb-memory-server
- **Development**: nodemon for hot reloading

## Project Structure
```
├── config/              # Configuration files
├── documentation/       # API documentation
├── middleware/          # Custom middleware (auth, error handling)
├── models/             # Mongoose schemas/models
├── routes/             # API route handlers
├── tests/              # Test files
├── utils/              # Utility functions and helpers
├── server.js           # Main application entry point
└── .env.example        # Environment variables template
```

## Coding Standards & Patterns

### 1. API Routes
- Use RESTful conventions (GET, POST, PUT, DELETE)
- Always include proper error handling with try-catch blocks
- Use express-validator for input validation
- Implement pagination for list endpoints (page, limit parameters)
- Include sorting and filtering capabilities
- Return consistent response format:
```javascript
{
  data: [...],
  pagination: { currentPage, totalPages, totalRecords, hasNext, hasPrev },
  message: "Success message",
  timestamp: "ISO date string"
}
```

### 2. Mongoose Models
- Include proper validation with custom error messages
- Use pre-save middleware for automatic timestamps
- Create appropriate database indexes for performance
- Include virtual properties where useful
- Follow naming convention: PascalCase for model names

### 3. Error Handling
- Use the centralized error handler in `middleware/errorHandler.js`
- Always validate ObjectIds before database operations
- Return appropriate HTTP status codes (400, 401, 403, 404, 500)
- Include validation errors in response when applicable

### 4. Security Practices
- Always validate and sanitize user input
- Use rate limiting on all routes
- Implement proper CORS configuration
- Use helmet for security headers
- Never expose sensitive information in error messages

### 5. Database Operations
- Use lean() for read-only operations to improve performance
- Implement proper aggregation pipelines for complex queries
- Use Promise.all() for parallel database operations
- Always handle MongoDB connection errors gracefully

## Key Models & Schemas

### WorkProgress
- Tracks construction work progress with stages: Pending, In Progress, Completed
- Required fields: workName, area, workAgency, scheme, technicalApproval, administrativeApproval, workProgressStage

### WorkOrder
- Manages work orders with status: Pending, Issued, Completed
- Automatically sets orderDate when status changes to 'Issued'
- Automatically sets completionDate when status changes to 'Completed'

### Tender
- Handles tender processes with status: Draft, Published, Bid Submission, Under Evaluation, Awarded, Cancelled
- Includes financial fields: tenderAmount, awardedAmount
- Has contractorName for awarded tenders

### AdministrativeApproval
- Manages approval workflows with status: Pending, Approved, Rejected, Under Review
- Includes approvalAuthority and approvalAmount fields
- Automatically sets approvalDate when status changes to 'Approved'

### WorkType
- Categorizes work types with department, engineer, priority levels
- Includes location fields: area, city, ward
- Has priority enum: Low, Medium, High, Critical

## Common Patterns & Helpers

### Validation Middleware
Always use validation arrays before route handlers:
```javascript
const validateWorkProgress = [
  body('workName').trim().notEmpty().withMessage('Work name is required'),
  body('area').trim().notEmpty().withMessage('Area is required'),
  // ... more validations
];
```

### Filter Building
Use the buildFilterQuery helper for consistent filtering:
```javascript
const buildFilterQuery = (queryParams) => {
  const filter = {};
  if (queryParams.area) filter.area = new RegExp(queryParams.area, 'i');
  if (queryParams.scheme) filter.scheme = new RegExp(queryParams.scheme, 'i');
  return filter;
};
```

### Pagination
Always implement pagination on list endpoints:
```javascript
const page = parseInt(req.query.page) || 1;
const limit = parseInt(req.query.limit) || 10;
const skip = (page - 1) * limit;
```

## Environment Variables
Reference these environment variables in configuration:
- `NODE_ENV` - Environment (development/production)
- `PORT` - Server port
- `MONGODB_URI` - MongoDB connection string
- `JWT_SECRET` - JWT secret key
- `FRONTEND_URL` - Frontend URL for CORS
- `RATE_LIMIT_WINDOW_MS` - Rate limiting window
- `RATE_LIMIT_MAX_REQUESTS` - Max requests per window

## Testing Guidelines
- Use Jest with supertest for API testing
- Use mongodb-memory-server for isolated test database
- Test all CRUD operations
- Test error scenarios (invalid IDs, validation failures)
- Test authentication and authorization
- Include setup and teardown in test files

## API Endpoints Convention
Base URL: `/api/v1`

Standard CRUD patterns:
- `GET /{resource}` - List with pagination, filtering, sorting
- `GET /{resource}/:id` - Get single resource
- `POST /{resource}` - Create new resource
- `PUT /{resource}/:id` - Update resource
- `DELETE /{resource}/:id` - Delete resource

Special endpoints:
- `GET /reports/{type}` - Generate reports
- `GET /health` - Health check

## Performance Considerations
- Use database indexes on frequently queried fields
- Implement lean() queries for read-only operations
- Use aggregation pipelines for complex data transformations
- Cache frequently accessed data where appropriate
- Implement proper connection pooling for MongoDB

## Security Considerations
- Always validate input data
- Use parameterized queries (Mongoose handles this)
- Implement rate limiting
- Use HTTPS in production
- Store JWT secrets securely
- Implement proper CORS policies

## When Adding New Features
1. Create/update Mongoose models with proper validation
2. Implement route handlers with full CRUD operations
3. Add input validation using express-validator
4. Include proper error handling
5. Write comprehensive tests
6. Update API documentation
7. Consider performance and security implications

## Common Imports
```javascript
const express = require('express');
const { body, validationResult, query } = require('express-validator');
const Model = require('../models/ModelName');
```

## Response Format Standards
Success responses:
```javascript
res.json({
  data: result,
  pagination: paginationInfo, // for list endpoints
  message: 'Operation successful'
});
```

Error responses:
```javascript
res.status(statusCode).json({
  message: 'Error description',
  errors: validationErrors, // if applicable
  timestamp: new Date().toISOString()
});
```

This backend follows enterprise-level patterns for scalability, maintainability, and security. Always consider these guidelines when suggesting code improvements or new features.


## recreate prompt

ok there is a major chaneg in the workflow of the website let me explain the work of the website to you properly

see this is a website where all the official work of the government for jashpur district takes place so whenever the governemnt needs any work to done or any department they submit a work proposal with all the required documents uploaded and added to it with all the infos including if it needs tender or not.

after this it goes to technical approval they do the approval and either select or reject it till thaat the status of the proposal is pending technical approval. after it is approved with all the approval documents uploaded with the proposal it goes to the administrative approval. and if its is rejected it is stored in the database with the reason for the rejection and its status is set to rejected technical approval the proposal creator can make necessary changes and add it for reaaproval of the technical approval team.

after the approval from the technical team it goes to the administrative approval with status pending administrative approval till any action, the same thing is repeated here as well the document upload for approval if it is approved and all same as above

Then if it contains tender then it wents to the tender process section and tender is provided to the tenderer by the respective organization under which the work is sanctioned and if the tender is not required then it goes directly to the sanctioned body and from there they convert it to a work order after this the status of the work order is monitored on a regular interval of time with document upload for work  progress till the work is completed 

after it is completed it is marked completed.